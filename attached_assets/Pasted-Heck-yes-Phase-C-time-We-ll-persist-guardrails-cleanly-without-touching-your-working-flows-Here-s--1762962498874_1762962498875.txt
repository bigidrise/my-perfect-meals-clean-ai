Heck yes—Phase C time. We’ll persist guardrails cleanly without touching your working flows. Here’s everything you asked for: migration, schema, routes, hooks, plus safe rollout + rollback.

# 1) Drizzle Migration (add JSONB column)

**File:** `server/drizzle/migrations/2025_11_12_add_guardrails_to_diabetes_profile.sql`

```sql
-- Up
ALTER TABLE diabetes_profile
ADD COLUMN guardrails JSONB DEFAULT NULL;

-- Down
ALTER TABLE diabetes_profile
DROP COLUMN guardrails;
```

If you’re using Drizzle Kit with TypeScript migrations instead of raw SQL, use this:

**File:** `server/drizzle/migrations/2025_11_12_add_guardrails_to_diabetes_profile.ts`

```ts
import { sql } from "drizzle-orm";

export const up = async (db: any) => {
  await db.execute(sql`
    ALTER TABLE diabetes_profile
    ADD COLUMN guardrails JSONB DEFAULT NULL;
  `);
};

export const down = async (db: any) => {
  await db.execute(sql`
    ALTER TABLE diabetes_profile
    DROP COLUMN guardrails;
  `);
};
```

# 2) Shared Schema Update (typed guardrails)

**File:** `shared/diabetes-schema.ts`

```ts
// Add this type
export type Guardrails = {
  fastingMin?: number;   // mg/dL
  fastingMax?: number;   // mg/dL
  postMealMax?: number;  // mg/dL
  carbLimit?: number;    // grams/day
  fiberMin?: number;     // grams/day
  giCap?: number;        // GI ceiling
  mealFrequency?: number; // meals/day
};

// Extend Zod schema (if you use it here)
import { z } from "zod";

export const GuardrailsZ = z.object({
  fastingMin: z.number().int().min(40).max(140).optional(),
  fastingMax: z.number().int().min(80).max(200).optional(),
  postMealMax: z.number().int().min(100).max(300).optional(),
  carbLimit: z.number().int().min(30).max(400).optional(),
  fiberMin: z.number().int().min(5).max(100).optional(),
  giCap: z.number().int().min(10).max(100).optional(),
  mealFrequency: z.number().int().min(2).max(8).optional(),
});

// Drizzle table (add column)
import { pgTable, jsonb, text, boolean, numeric } from "drizzle-orm/pg-core";

export const diabetesProfile = pgTable("diabetes_profile", {
  id: text("id").primaryKey(),
  userId: text("user_id").notNull(),
  type: text("type").notNull(),
  medications: text("medications").array(),
  a1cPercent: numeric("a1c_percent"),
  hypoHistory: boolean("hypo_history"),
  guardrails: jsonb("guardrails").$type<Guardrails | null>().default(null),
});

// Optional defaults for client fallback
export const DEFAULT_GUARDRAILS: Guardrails = {
  fastingMin: 80,
  fastingMax: 120,
  postMealMax: 140,
  carbLimit: 120,
  fiberMin: 25,
  giCap: 55,
  mealFrequency: 4,
};
```

# 3) Server Route Patch (accept/persist guardrails)

**File:** `server/routes/diabetes.ts`

```ts
import { z } from "zod";
import { GuardrailsZ } from "../../shared/diabetes-schema";
import { diabetesProfile } from "../db/schema";
import { eq } from "drizzle-orm";

const ProfileUpdateZ = z.object({
  type: z.string().optional(),
  medications: z.array(z.string()).optional(),
  a1cPercent: z.number().optional(),
  hypoHistory: z.boolean().optional(),
  guardrails: GuardrailsZ.nullable().optional(),
});

app.put("/api/diabetes/profile", authRequired, async (req, res) => {
  const user = req.user!;
  const parsed = ProfileUpdateZ.safeParse(req.body);
  if (!parsed.success) return res.status(400).json(parsed.error.format());

  const data = parsed.data;

  // upsert-style: if profile exists → update; else create
  const existing = await db.query.diabetesProfile.findFirst({
    where: eq(diabetesProfile.userId, user.id),
  });

  if (!existing) {
    const insertData = {
      userId: user.id,
      type: data.type ?? "diabetic",
      medications: data.medications ?? [],
      a1cPercent: data.a1cPercent ?? null,
      hypoHistory: data.hypoHistory ?? null,
      guardrails: data.guardrails ?? null,
      id: crypto.randomUUID(),
    };
    await db.insert(diabetesProfile).values(insertData);
    return res.json(insertData);
  } else {
    const updateData: any = {};
    if (data.type !== undefined) updateData.type = data.type;
    if (data.medications !== undefined) updateData.medications = data.medications;
    if (data.a1cPercent !== undefined) updateData.a1cPercent = data.a1cPercent;
    if (data.hypoHistory !== undefined) updateData.hypoHistory = data.hypoHistory;
    if (data.guardrails !== undefined) updateData.guardrails = data.guardrails;

    const updated = await db
      .update(diabetesProfile)
      .set(updateData)
      .where(eq(diabetesProfile.userId, user.id))
      .returning();
    return res.json(updated[0]);
  }
});
```

> If you have a GET route for profile, no changes needed beyond ensuring `guardrails` is selected/returned.

# 4) Client Hook Modifications

**File:** `client/src/hooks/useDiabetes.ts`

```ts
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { api } from "../lib/api";
import type { Guardrails } from "../../../shared/diabetes-schema";

// Fetch profile (now includes guardrails)
export function useDiabetesProfile(userId?: string) {
  return useQuery({
    queryKey: ["diabetesProfile", userId],
    queryFn: async () => {
      const { data } = await api.get("/api/diabetes/profile");
      return data as { guardrails?: Guardrails | null } & Record<string, any>;
    },
    enabled: !!userId,
  });
}

// Save profile (accept guardrails)
export function useSaveDiabetesProfile() {
  const qc = useQueryClient();
  return useMutation({
    mutationFn: async (payload: Partial<{ 
      type: string;
      medications: string[];
      a1cPercent: number;
      hypoHistory: boolean;
      guardrails: Guardrails | null;
    }>) => {
      const { data } = await api.put("/api/diabetes/profile", payload);
      return data;
    },
    onSuccess: () => {
      qc.invalidateQueries({ queryKey: ["diabetesProfile"] });
    },
  });
}
```

**In your `DiabeticHub.tsx` (Phase C binding only—no layout changes):**

* On mount, prime guardrail UI state with `profile.guardrails ?? DEFAULT_GUARDRAILS`.
* On “Save Guardrails”, call:

```ts
saveProfile.mutate({ guardrails }); // keep other fields untouched unless present
```

# 5) Meal Builder (no change needed)

Your existing `DiabeticMenuBuilder.tsx` should continue to call `useMealConstraints(userId)`. Enhance that hook (if not already) to factor in `profile.guardrails` (max carbs, GI cap, etc.). No route-state props.

# 6) Zod Validation (client UI messages)

If you surface field errors client-side, you can reuse the same `GuardrailsZ` schema for immediate messages (e.g., “Fasting Min must be between 40–140”). Not required, but keeps UX tight.

# 7) Rollout Plan (safe + reversible)

1. **Create migration** → run it:

```bash
# whichever you use
npm run drizzle:push
# or
npm run db:migrate
```

2. **Update shared + server + client hooks** (in one PR)

3. **Smoke test**:

* Load `/diabetic-hub` → `useDiabetesProfile()` returns `guardrails: null` initially
* Edit guardrails → Save → Confirm PUT success → Reload page → Values hydrate from server
* Log glucose → unaffected
* Generate meals → builder still uses `useMealConstraints` (now enriched by guardrails if your hook reads them)

4. **Commit**:

```
./push.sh "feat(diabetic-hub): Phase C – persist doctor guardrails (JSONB) + API + hooks"
```

5. **Rollback** (if needed):

* Revert PR
* Run migration down script to drop column

—

That’s the full Phase C package—no fluff, no surprise side-effects. If you want, I can also hand you a minimal patch for `useMealConstraints(userId)` to read `profile.guardrails` and derive `maxCarbsGrams`, `preferLowGlycemic` (when `giCap` present), and filter sets.
