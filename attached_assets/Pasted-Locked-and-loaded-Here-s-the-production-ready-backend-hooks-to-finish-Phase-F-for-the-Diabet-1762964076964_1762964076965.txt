Locked and loaded. Hereâ€™s the **production-ready backend + hooks** to finish Phase F for the *Diabetic Patient Assignment Dashboard* â€” diabetes-only, no GLP-1 mixing.

# 0) Migration â€” Audit Trail Table

**File:** `server/drizzle/migrations/2025_11_12_create_guardrail_audit_log.sql`

```sql
-- Up
CREATE TABLE guardrail_audit_log (
  id TEXT PRIMARY KEY,
  doctor_id TEXT NOT NULL,
  patient_id TEXT NOT NULL,
  field TEXT NOT NULL,
  old_value JSONB,
  new_value JSONB,
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Down
DROP TABLE guardrail_audit_log;
```

# 1) Shared Schema (Types)

**File:** `shared/diabetes-schema.ts`

```ts
export type Guardrails = {
  fastingMin?: number;
  fastingMax?: number;
  postMealMax?: number;
  carbLimit?: number;
  fiberMin?: number;
  giCap?: number;
  mealFrequency?: number;
  presetId?: string | null; // optional: track which preset applied
};

export type PatientSummary = {
  id: string;
  name: string;
  email: string;
  condition: "T2D" | "CARDIAC_DIABETIC" | "OTHER";
  latestGlucose: number | null;
  inRange: boolean | null;
  preset: string | null;
  carbLimit: number | null;
  lastUpdated: string | null;
};

export type GuardrailAuditRow = {
  id: string;
  doctorId: string;
  patientId: string;
  field: string;
  oldValue: unknown;
  newValue: unknown;
  updatedAt: string;
};
```

# 2) Drizzle Table for Audit

**File:** `server/db/schema.ts` (add)

```ts
import { pgTable, text, jsonb, timestamp } from "drizzle-orm/pg-core";

export const guardrailAuditLog = pgTable("guardrail_audit_log", {
  id: text("id").primaryKey(),
  doctorId: text("doctor_id").notNull(),
  patientId: text("patient_id").notNull(),
  field: text("field").notNull(),
  oldValue: jsonb("old_value"),
  newValue: jsonb("new_value"),
  updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow().notNull(),
});
```

# 3) Server Endpoints (Express + Drizzle)

**Assumptions**

* Auth middleware sets `req.user = { id, role }`.
* Tables: `users`, `patients` (link doctorâ†’patient), `diabetes_profile`, `glucose_logs`.
* You already have `diabetes_profile.guardrails JSONB`.

**File:** `server/routes/patients.diabetes.ts`

```ts
import { Router } from "express";
import { and, desc, eq } from "drizzle-orm";
import { db } from "../db";
import { users, patients, diabetesProfile, glucoseLogs } from "../db/schema"; // your existing tables
import { guardrailAuditLog } from "../db/schema";
import { z } from "zod";
import crypto from "crypto";

const r = Router();

// ---- Guards ----
function proRole(req, res, next) {
  const role = req.user?.role;
  if (!role || !["doctor", "coach", "trainer"].includes(role)) {
    return res.status(403).json({ error: "Forbidden" });
  }
  next();
}

// ---- Helpers ----
const GuardrailsZ = z.object({
  fastingMin: z.number().int().optional(),
  fastingMax: z.number().int().optional(),
  postMealMax: z.number().int().optional(),
  carbLimit: z.number().int().optional(),
  fiberMin: z.number().int().optional(),
  giCap: z.number().int().optional(),
  mealFrequency: z.number().int().optional(),
  presetId: z.string().nullable().optional(),
}).partial();

function computeInRange(glucose: number | null, gr?: any): boolean | null {
  if (glucose == null) return null;
  const fmin = gr?.fastingMin ?? 80;
  const fmax = gr?.fastingMax ?? 120;
  // Fallback heuristic: use fasting bounds for latest single reading
  return glucose >= fmin && glucose <= fmax;
}

// ========== GET /api/patients (diabetes only) ==========
r.get("/api/patients", proRole, async (req: any, res) => {
  const doctorId = req.user.id;

  // Patients assigned to this clinician (diabetic only)
  // Adjust your join/filters to your schema names
  const rows = await db
    .select({
      patientId: patients.patientId,
      userId: users.id,
      name: users.name,
      email: users.email,
      guardrails: diabetesProfile.guardrails,
      lastUpdated: diabetesProfile.updatedAt, // if you have it
    })
    .from(patients)
    .leftJoin(users, eq(users.id, patients.patientId))
    .leftJoin(diabetesProfile, eq(diabetesProfile.userId, patients.patientId))
    .where(eq(patients.doctorId, doctorId));

  // latest glucose per patient
  const results = await Promise.all(
    rows.map(async (row) => {
      const latest = await db
        .select({ value: glucoseLogs.valueMgdl, at: glucoseLogs.recordedAt })
        .from(glucoseLogs)
        .where(eq(glucoseLogs.userId, row.userId))
        .orderBy(desc(glucoseLogs.recordedAt))
        .limit(1);

      const latestGlucose = latest[0]?.value ?? null;
      const inRange = computeInRange(latestGlucose, row.guardrails ?? undefined);
      const carbLimit = row.guardrails?.carbLimit ?? null;
      const preset = row.guardrails?.presetId ?? null;

      return {
        id: row.userId,
        name: row.name ?? "Unknown",
        email: row.email ?? "",
        condition: "T2D",
        latestGlucose,
        inRange,
        preset,
        carbLimit,
        lastUpdated: row.lastUpdated ?? null,
      };
    })
  );

  res.json(results);
});

// ========== GET /api/patients/:id ==========
r.get("/api/patients/:id", proRole, async (req: any, res) => {
  const doctorId = req.user.id;
  const patientId = req.params.id;

  // verify relationship (doctor has this patient)
  const rel = await db.query.patients.findFirst({
    where: and(eq(patients.doctorId, doctorId), eq(patients.patientId, patientId)),
  });
  if (!rel) return res.status(403).json({ error: "Not your patient" });

  const profile = await db.query.diabetesProfile.findFirst({
    where: eq(diabetesProfile.userId, patientId),
  });

  const logs = await db
    .select({
      value: glucoseLogs.valueMgdl,
      context: glucoseLogs.context,
      at: glucoseLogs.recordedAt,
    })
    .from(glucoseLogs)
    .where(eq(glucoseLogs.userId, patientId))
    .orderBy(desc(glucoseLogs.recordedAt))
    .limit(50);

  res.json({
    profile: profile ?? null,
    guardrails: profile?.guardrails ?? null,
    glucose: logs,
  });
});

// ========== PUT /api/patients/:id/guardrails ==========
r.put("/api/patients/:id/guardrails", proRole, async (req: any, res) => {
  const doctorId = req.user.id;
  const patientId = req.params.id;

  const rel = await db.query.patients.findFirst({
    where: and(eq(patients.doctorId, doctorId), eq(patients.patientId, patientId)),
  });
  if (!rel) return res.status(403).json({ error: "Not your patient" });

  const parsed = GuardrailsZ.safeParse(req.body?.guardrails ?? {});
  if (!parsed.success) return res.status(400).json(parsed.error.format());

  const newGR = parsed.data;

  const existing = await db.query.diabetesProfile.findFirst({
    where: eq(diabetesProfile.userId, patientId),
  });

  const oldGR = existing?.guardrails ?? null;

  if (!existing) {
    await db.insert(diabetesProfile).values({
      id: crypto.randomUUID(),
      userId: patientId,
      type: "diabetic",
      medications: [],
      a1cPercent: null,
      hypoHistory: null,
      guardrails: newGR,
    });
  } else {
    await db
      .update(diabetesProfile)
      .set({ guardrails: newGR })
      .where(eq(diabetesProfile.userId, patientId));
  }

  // audit (one row storing full old/new objects is fine;
  // optionally emit one per changed key instead)
  await db.insert(guardrailAuditLog).values({
    id: crypto.randomUUID(),
    doctorId,
    patientId,
    field: "guardrails",
    oldValue: oldGR,
    newValue: newGR,
  });

  res.json({ ok: true });
});

// ========== GET /api/patients/:id/audit ==========
r.get("/api/patients/:id/audit", proRole, async (req: any, res) => {
  const doctorId = req.user.id;
  const patientId = req.params.id;

  const rel = await db.query.patients.findFirst({
    where: and(eq(patients.doctorId, doctorId), eq(patients.patientId, patientId)),
  });
  if (!rel) return res.status(403).json({ error: "Not your patient" });

  const rows = await db
    .select({
      id: guardrailAuditLog.id,
      doctorId: guardrailAuditLog.doctorId,
      patientId: guardrailAuditLog.patientId,
      field: guardrailAuditLog.field,
      oldValue: guardrailAuditLog.oldValue,
      newValue: guardrailAuditLog.newValue,
      updatedAt: guardrailAuditLog.updatedAt,
    })
    .from(guardrailAuditLog)
    .where(eq(guardrailAuditLog.patientId, patientId))
    .orderBy(desc(guardrailAuditLog.updatedAt));

  res.json(rows);
});

export default r;
```

> Mount this router in `server/index.ts` after auth:
> `app.use(require("./routes/patients.diabetes").default);`

# 4) Client Hooks (React Query)

**File:** `client/src/hooks/usePatients.ts`

```ts
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { api } from "../lib/api";
import type { PatientSummary, GuardrailAuditRow, Guardrails } from "../../../shared/diabetes-schema";

export function usePatients() {
  return useQuery({
    queryKey: ["patients"],
    queryFn: async () => {
      const { data } = await api.get<PatientSummary[]>("/api/patients");
      return data;
    },
    staleTime: 30_000, // aligns with polling
    refetchInterval: 30_000,
  });
}

export function usePatient(patientId: string) {
  return useQuery({
    queryKey: ["patient", patientId],
    queryFn: async () => {
      const { data } = await api.get(`/api/patients/${patientId}`);
      return data as {
        profile: { guardrails?: Guardrails | null } | null;
        guardrails: Guardrails | null;
        glucose: { value: number; context: string; at: string }[];
      };
    },
    enabled: !!patientId,
  });
}

export function useUpdatePatientGuardrails(patientId: string) {
  const qc = useQueryClient();
  return useMutation({
    mutationFn: async (guardrails: Guardrails) => {
      await api.put(`/api/patients/${patientId}/guardrails`, { guardrails });
    },
    onSuccess: () => {
      qc.invalidateQueries({ queryKey: ["patients"] });
      qc.invalidateQueries({ queryKey: ["patient", patientId] });
    },
  });
}

export function usePatientAudit(patientId: string) {
  return useQuery({
    queryKey: ["patient-audit", patientId],
    queryFn: async () => {
      const { data } = await api.get<GuardrailAuditRow[]>(`/api/patients/${patientId}/audit`);
      return data;
    },
    enabled: !!patientId,
  });
}
```

# 5) UI Wiring (Dashboard + Modals)

* **Table** uses `usePatients()` to populate rows.
* **View/Edit** button opens modal:

  * Fetch `usePatient(patientId)`.
  * Bind inputs to `data.guardrails` (fallback to defaults).
  * â€œApply Presetâ€ â†’ overwrite local guardrail values.
  * â€œSave Changesâ€ â†’ `useUpdatePatientGuardrails(patientId).mutate(guardrails)`.
  * On success: toast + modal close.
* **History** button opens modal with `usePatientAudit(patientId)`; render table with field diffs.

# 6) Security

* Ensure `/api/patients*` routes are behind your auth middleware and `proRole` check.
* On the client, hide `/procare/patient-assignment` behind a role gate (doctor/coach/trainer).

# 7) QA Checklist

* **Filters**: search + preset filter + condition filter work together (client-side first; server-side later if dataset grows).
* **Colors**: glucose status chips map correctly (âœ…/âš ï¸/ğŸ”´).
* **Edits**: preset apply â†’ tweak â†’ save â†’ toast â†’ dashboard refresh.
* **Audit**: entries appear with correct `doctor_id` and JSON diffs.
* **Polling**: patients list auto-refreshes every 30s (no flicker).

# 8) Commit

```bash
./push.sh "feat(procare-dashboard): Phase F production â€“ patients API, edit modals, audit trail, polling"
```

If you want, I can hand you a **drop-in View/Edit modal component** next (props: `patientId`, guards: open/close callbacks), wired to these hooks with your black-glass aesthetic.
