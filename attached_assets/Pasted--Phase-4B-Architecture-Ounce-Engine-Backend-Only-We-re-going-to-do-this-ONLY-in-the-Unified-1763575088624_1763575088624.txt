üß† Phase 4B Architecture ‚Äì ‚ÄúOunce Engine‚Äù (Backend Only)

We‚Äôre going to do this ONLY in the UnifiedMeal layer, so:

Legacy responses stay exactly as they are.

Only UnifiedMeal.ingredients get the new ounce logic.

Frontend isn‚Äôt touched yet; it can opt into UnifiedMeal when we do Phase 4A.

1. Extend UnifiedIngredient (server/services/unification/types.ts)

Right now we basically have:

interface UnifiedIngredient {
  name: string;
  quantity?: string;
  unit?: string;
  notes?: string;
}


We‚Äôre going to extend it to support ounces while staying backward-compatible:

interface UnifiedIngredient {
  name: string;              // "Chicken Breast"
  quantity?: string;         // original human-readable amount ("1", "3-4", "to taste")
  unit?: string;             // original unit ("oz", "lb", "cup", "tsp", etc.)
  notes?: string;            // "diced", "to taste"

  // NEW: canonical measurement in ounces where possible
  quantityOz?: number;       // rounded UP to nearest 0.5 oz
  displayQuantity?: string;  // e.g. "8 oz (1 cup)" or "24 oz (1.5 lb)"
  originalUnit?: string;     // preserves raw unit before conversion (if different)
}


No one is using quantityOz or displayQuantity yet, so this is 100% safe to add.

2. New utility: measurementNormalizer.ts

New file:
server/services/unification/utils/measurementNormalizer.ts

Core function:

import type { UnifiedIngredient } from "../types";

export function normalizeIngredientMeasurements(
  ingredients: UnifiedIngredient[]
): UnifiedIngredient[] {
  return ingredients.map(applyOunceNormalization);
}


Internal logic (high-level, not pseudo-bullshit):

function applyOunceNormalization(ing: UnifiedIngredient): UnifiedIngredient {
  const out: UnifiedIngredient = { ...ing };

  const rawQty = ing.quantity?.trim() ?? "";
  const rawUnit = (ing.unit || "").toLowerCase().trim();

  // 1) Bail early for tsp/tbsp and non-numeric weird stuff
  if (
    !rawQty ||
    /tsp|teaspoon|tbsp|tablespoon|pinch|dash|to taste/i.test(rawUnit + " " + rawQty)
  ) {
    return out; // no ounce conversion
  }

  const numeric = parseNumericQuantity(rawQty);
  if (numeric == null || isNaN(numeric)) return out;

  // 2) Convert to base ounces
  const oz = toOunces(numeric, rawUnit);
  if (oz == null || isNaN(oz)) return out;

  // 3) Round UP to nearest 0.5
  const roundedOz = roundUpToHalf(oz);

  // 4) Compute cup / pound equivalents
  const cups = roundedOz / 8;
  const pounds = roundedOz / 16;

  // 5) Build display string: always ounces first
  let display = `${roundedOz} oz`;

  // If original unit was a cup-like thing, show cups
  if (/cup|cups|c\b/.test(rawUnit)) {
    const cupStr = formatHalfSteps(cups); // 1, 1.5, 2, etc.
    display = `${roundedOz} oz (${cupStr} cup${cupStr === "1" ? "" : "s"})`;
  } else if (roundedOz >= 16) {
    const lbStr = formatHalfSteps(pounds); // 1, 1.5, 2, etc.
    display = `${roundedOz} oz (${lbStr} lb${lbStr === "1" ? "" : "s"})`;
  }

  out.quantityOz = roundedOz;
  out.displayQuantity = display;
  out.originalUnit = ing.unit ?? rawUnit;

  // Optionally, you can also standardize unit to "oz"
  out.unit = "oz";

  return out;
}


Supporting helpers:

function parseNumericQuantity(q: string): number | null {
  // handle "3", "1.5", "3-4", "2 to 3"
  const rangeMatch = q.match(/(\d+(\.\d+)?)[^\d]+(\d+(\.\d+)?)/);
  if (rangeMatch) {
    const hi = parseFloat(rangeMatch[3]);
    return isNaN(hi) ? null : hi; // ALWAYS ROUND UP: use upper bound
  }

  const numMatch = q.match(/(\d+(\.\d+)?)/);
  return numMatch ? parseFloat(numMatch[1]) : null;
}

function toOunces(value: number, unit: string): number | null {
  if (!unit) return value; // assume already oz if unit is blank

  if (/oz|ounce/.test(unit)) return value;
  if (/lb|pound/.test(unit)) return value * 16;
  if (/kg/.test(unit))       return value * 35.274;
  if (/g\b|gram/.test(unit)) return value / 28.3495;
  if (/cup|cups|c\b/.test(unit)) return value * 8;

  // Unknown unit
  return null;
}

function roundUpToHalf(oz: number): number {
  return Math.ceil(oz * 2) / 2;
}

function formatHalfSteps(v: number): string {
  // 1.0, 1.5, 2.0 ‚Üí "1", "1.5", "2"
  const rounded = Math.round(v * 2) / 2;
  return Number.isInteger(rounded) ? String(rounded) : rounded.toFixed(1);
}


Again: this ONLY fills extra fields on UnifiedIngredient. Nothing legacy is touched.

3. Wire it into ALL UnifiedMeal mappers

Anywhere we build ingredients in mappers, we run them through the normalizer.

Examples:

Fridge Rescue mapper
import { normalizeIngredientMeasurements } from "../utils/measurementNormalizer";

export function mapFridgeRescueMeal(meal: FridgeRescueMeal, source: MealSource): UnifiedMeal {
  const baseIngredients: UnifiedIngredient[] = meal.ingredients.map(i => ({
    name: i.name,
    quantity: i.quantity,
    unit: i.unit,
  }));

  const ingredients = normalizeIngredientMeasurements(baseIngredients);

  return {
    // ...
    ingredients,
    // ...
  };
}

Craving Creator mapper

Account for the fact Craving Creator uses amount not quantity:

const baseIngredients: UnifiedIngredient[] = meal.ingredients.map(i => ({
  name: i.name,
  quantity: String(i.amount),
  unit: i.unit,
}));

const ingredients = normalizeIngredientMeasurements(baseIngredients);

Restaurant Guide / Meal Finder mappers

They only have string[] ingredients like "grilled chicken breast" with no numeric data. That‚Äôs fine:

const baseIngredients: UnifiedIngredient[] = (meal.ingredients || []).map(name => ({
  name,
}));

const ingredients = normalizeIngredientMeasurements(baseIngredients);


The normalizer will basically no-op when there‚Äôs no quantity/unit.

AI Premades

Premades already build structured ingredients; we wrap them exactly the same way into normalizeIngredientMeasurements.

4. Safety guarantees

Legacy responses: untouched.

UnifiedMeal shape: only extended, not changed.

If quantity/unit is weird ‚Üí we just don‚Äôt set quantityOz / displayQuantity.

tsp/tbsp and ‚Äúto taste‚Äù stay exactly as-is.

üõ† Replit Agent Prompt ‚Äì Phase 4B (Ounce System) in STRICT MODE

You don‚Äôt have to do any of this by hand.
Here‚Äôs the exact prompt to hand to the Agent (STRICT MODE already active):

PHASE 4B ‚Äì OUNCE-BASED INGREDIENT UNIFICATION (STRICT MODE)

Goal:
Implement a non-breaking ounce-based measurement system ONLY in the UnifiedMeal layer.

Rules (from founder):
- Round ALL converted ounce values UP to nearest 0.5 (0.5, 1.0, 1.5, 2.0, etc.).
- Cups: ALWAYS treat 1 cup = 8 oz.
- Pounds: ALWAYS treat 1 lb = 16 oz.
- Values over 1 lb must be displayed as "<oz> oz (<lb> lb)", e.g. "24 oz (1.5 lb)".
- tsp/tbsp and ‚Äúto taste‚Äù style units stay as-is (no ounce conversion).
- No tooltips needed now ‚Äì display is textual only.
- Legacy route responses MUST NOT change. Only UnifiedMeal is enhanced.

Implementation steps (STRICT MODE applies to ALL of this):

1) Extend UnifiedIngredient type
   File: server/services/unification/types.ts

   Add OPTIONAL fields to UnifiedIngredient:
   - quantityOz?: number;
   - displayQuantity?: string;
   - originalUnit?: string;

   Do NOT remove any existing fields.

2) Create measurementNormalizer utility
   File: server/services/unification/utils/measurementNormalizer.ts

   Implement:
   - normalizeIngredientMeasurements(ingredients: UnifiedIngredient[]): UnifiedIngredient[]
     ‚Ä¢ For each ingredient, apply:
       - parse numeric quantity (support "3", "1.5", "3-4", "2 to 3")
       - if unit includes tsp/tbsp/teaspoon/tablespoon/pinch/dash/"to taste" ‚Üí return unchanged
       - convert g/kg/lb/oz/cup ‚Üí ounces (using rules above)
       - round UP to nearest 0.5 using ceil(oz * 2) / 2
       - build displayQuantity:
         ‚Ä¢ if original unit is cup-like: "X oz (Y cup/cups)"
         ‚Ä¢ else if X >= 16: "X oz (Y lb/lbs)"
         ‚Ä¢ else just "X oz"
       - set:
         ‚Ä¢ quantityOz
         ‚Ä¢ displayQuantity
         ‚Ä¢ originalUnit (from original unit before conversion)
         ‚Ä¢ unit = "oz" when conversion applied

3) Wire measurementNormalizer into ALL UnifiedMeal mappers
   Files:
   - server/services/unification/mappers/fridgeRescueMapper.ts
   - server/services/unification/mappers/cravingCreatorMapper.ts
   - server/services/unification/mappers/restaurantGuideMapper.ts
   - server/services/unification/mappers/mealFinderMapper.ts
   - server/services/unification/mappers/aiPremadeMapper.ts
   - server/services/unification/mappers/aiMealCreatorMapper.ts (if separate)

   For each mapper:
   - Construct a UnifiedIngredient[] from the source meal‚Äôs ingredient format.
   - Call normalizeIngredientMeasurements() and use the returned array as UnifiedMeal.ingredients.
   - DO NOT change any other fields or route response structures.

4) STRICT MODE REQUIREMENTS
   - BEFORE editing: show rg -n "UnifiedIngredient" and all mapper files.
   - AFTER editing each file: show git diff --unified=3 and updated snippets.
   - Restart workflow when complete and show full logs.
   - Call architect and have them verify:
     ‚Ä¢ UnifiedIngredient now supports quantityOz/displayQuantity/originalUnit.
     ‚Ä¢ All mappers call normalizeIngredientMeasurements().
     ‚Ä¢ Legacy responses are untouched.
     ‚Ä¢ UnifiedMeal validation still passes.

No frontend changes. No route shape changes. This is backend-only, UnifiedMeal-only, measurement enhancement.

Begin.
