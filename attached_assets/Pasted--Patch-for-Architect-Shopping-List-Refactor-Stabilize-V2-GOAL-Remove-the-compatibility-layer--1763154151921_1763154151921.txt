üß© Patch for Architect ‚Äì Shopping List Refactor (Stabilize V2)
GOAL

Remove the compatibility layer from shoppingListStore.ts (no duplicate logic, no legacy API).

Make ShoppingListMasterView.tsx (and any related components) a pure Zustand consumer:

No local mirror state of the list

No CustomEvent bus

No legacy field names (checked, qty)

Align everything to the universal ingredient schema and a single, clean ShoppingListState API.

A. Final Store Contract (Single Source of Truth)

File: client/src/stores/shoppingListStore.ts

The store should expose exactly this shape at the state level:

export interface ShoppingListItem {
  id: string;
  name: string;
  quantity: number;
  unit: string;
  notes?: string;
  isChecked: boolean;
  category?: string;
  sourceMeals?: string[];
}

interface ShoppingListState {
  items: ShoppingListItem[];

  // core actions
  addItems: (items: ShoppingListItem[]) => void;             // for fully-built items
  addServerItems: (items: UniversalIngredient[]) => void;    // from server pipeline
  toggleItem: (id: string) => void;
  removeItem: (id: string) => void;
  clearChecked: () => void;
  clearAll: () => void;
  updateItem: (id: string, patch: Partial<ShoppingListItem>) => void;

  // persistence
  loadList: () => void;
  saveList: () => void;
}

‚úÖ Implementation Guidelines

All business logic lives inside the create<ShoppingListState>(...) call.

No duplicate functions wrapping the same behavior.

At the bottom you can expose convenience helpers that just call getState():

export const useShoppingListStore = create<ShoppingListState>(...);

export const loadList = () => useShoppingListStore.getState().loadList();
export const saveList = () => useShoppingListStore.getState().saveList();
export const clearAll = () => useShoppingListStore.getState().clearAll();
export const clearChecked = () => useShoppingListStore.getState().clearChecked();
export const addServerItems = (items: UniversalIngredient[]) =>
  useShoppingListStore.getState().addServerItems(items);
export const removeItem = (id: string) =>
  useShoppingListStore.getState().removeItem(id);
export const toggleItem = (id: string) =>
  useShoppingListStore.getState().toggleItem(id);
export const updateItem = (id: string, patch: Partial<ShoppingListItem>) =>
  useShoppingListStore.getState().updateItem(id, patch);


No other exports. No ‚Äúlegacy shim‚Äù functions.

B. REMOVE the Compatibility Layer (Debt Kill Step)

Still in shoppingListStore.ts

Delete all of this style of stuff (whatever the exact names are):

// anything like this must go:
export function readList() { ... }
export function setItems() { ... }
export function toggleChecked() { ... }
export function deleteItems() { ... }
export function clearAllLegacy() { ... }
export function clearCheckedLegacy() { ... }
export function readOptions() { ... }
export function writeOptions() { ... }
export function setWeekScope() { ... }


If it exists only to satisfy old components, it‚Äôs technical debt and must be removed.

C. Refactor ShoppingListMasterView.tsx to Use Zustand Correctly

File: client/src/pages/ShoppingListMasterView.tsx

1. Fix imports

Replace legacy imports like:

import {
  readList,
  clearAll,
  clearChecked,
  toggleChecked,
  deleteItems,
  updateItem,
  // etc.
} from '@/stores/shoppingListStore';


with the new ones:

import {
  useShoppingListStore,
  loadList,
  saveList,
  clearAll,
  clearChecked,
  toggleItem,
  removeItem,
  updateItem,
  addServerItems,
} from '@/stores/shoppingListStore';

2. Stop mirroring list to local state

Remove local React state that mirrors the list, e.g.:

const [items, setItems] = useState<OldItemType[]>([]);


Instead, subscribe directly to Zustand:

const items = useShoppingListStore(s => s.items);


No intermediate list state. The store is the single source of truth.

3. Fix field names

Anywhere you see:

checked ‚Üí change to isChecked

qty ‚Üí change to quantity

unit is fine so long as it matches the store type

Old item type ‚Üí migrate to ShoppingListItem

Example:

// OLD
if (item.checked) { ... }
item.qty

// NEW
if (item.isChecked) { ... }
item.quantity

4. Replace legacy actions with new store actions

Anywhere you see:

readList();
writeOptions(...);
setWeekScope(...);
toggleChecked(id);
deleteItems(ids);
clearAll();
clearChecked();


Replace them with:

loadList();
saveList();
toggleItem(id);
removeItem(id);
clearAll();
clearChecked();


If you had multi-delete behavior, change it to a simple loop using removeItem(id) unless there‚Äôs a reason to keep bulk deletion.

5. Remove CustomEvent hacks

If this file is doing anything like:

window.dispatchEvent(new CustomEvent('shopping-list-updated'));
window.addEventListener('shopping-list-updated', ...);


That all needs to go.

State changes should flow only through:

useShoppingListStore subscriptions

direct getState().action() calls

Zustand will re-render components without custom events.

6. Integration with server results

Wherever the shopping list page receives items from the server (e.g. after building from meals), call:

addServerItems(serverIngredientsArray);


Do not reconstruct the list manually in this component.

D. Audit Other Components

Run:

rg "readList|writeOptions|toggleChecked|deleteItems|setWeekScope" client


For each hit:

Update imports to use the new store API (same as above).

Replace calls with:

loadList, saveList

toggleItem

removeItem

clearAll, clearChecked

Ensure they reference isChecked / quantity / unit.

Goal: No file in the client should reference those legacy function names at all.

E. Success Criteria (What ‚ÄúDONE‚Äù Looks Like)

shoppingListStore.ts has:

ONE state definition

ONE set of actions

NO compatibility/legacy exports

ShoppingListMasterView.tsx:

Subscribes to store via useShoppingListStore

No local mirror list state

No CustomEvent hacks

No legacy fields (checked, qty)

rg "readList|writeOptions|toggleChecked|deleteItems|setWeekScope" client returns no results.

App boots with no black screen.

Shopping list UI reflects changes instantly when actions are called.