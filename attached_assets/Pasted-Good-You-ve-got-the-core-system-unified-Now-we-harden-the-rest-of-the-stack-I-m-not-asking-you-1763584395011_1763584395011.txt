Good. Youâ€™ve got the core system unified. Now we harden the rest of the stack.

Iâ€™m not asking you shit.
Hereâ€™s the next wave, exactly how to feed it to the Architect/Agent.

---

## ðŸ›  FIX #6 â€” MealHubFactory Normalization

**Goal:** Every meal entering the hub is already in the unified frontend shape:
`{ name, ingredients[], instructions[], macros, ounces, item + name preserved }`
No custom conversions hiding in here.

### ðŸ”§ Architect Script for Fix #6

Give this to the Agent/Architect:

```bash
# FIX #6 â€“ Inspect MealHubFactory for legacy transformations
rg -n "MealHubFactory" client/src
rg -n "UnifiedMeal" client/src/features/meals/MealHubFactory.tsx || true
rg -n "ingredients" client/src/features/meals/MealHubFactory.tsx
rg -n "calories" client/src/features/meals/MealHubFactory.tsx
```

Then:

```bash
sed -n '140,230p' client/src/features/meals/MealHubFactory.tsx
```

### What the Architect must do inside `MealHubFactory.tsx`:

1. **Remove any local â€œconversionâ€ logic** that tries to turn a backend meal into a UI meal
   (anything like: `item: ing.item || ing.name`, `amount: ing.quantity || ing.amount`, etc).

2. Assume ALL generator paths now deliver **normalized meals** from `normalizeUnifiedMealOutput`.

   So any code that currently looks like:

   ```ts
   const meal = /* some raw response meal */;
   const uiMeal = {
     name: meal.title,
     ingredients: meal.ingredients.map(...),
     ...
   };
   ```

   should be simplified to:

   ```ts
   const uiMeal = meal; // already normalized upstream
   ```

3. **If MealHubFactory is still receiving raw backend meals** (it shouldnâ€™t, but if it is), then:

   * Import the normalizer at the top:

     ```ts
     import { normalizeUnifiedMealOutput } from "@/lib/mealEngineApi";
     ```
   * Immediately normalize wherever the raw meal arrives:

     ```ts
     const uiMeal = normalizeUnifiedMealOutput(meal);
     ```

4. Do **not** change any routing logic, just strip redundant transforms.

---

## ðŸ›  FIX #7 â€” mealActions API (save / log / replace meal)

**Goal:** All CRUD ops for meals work cleanly with the new normalized shape.

File from your earlier rg:
`client/src/lib/api/mealActions.ts`

### ðŸ”§ Architect Script for Fix #7

```bash
# See all mealActions
sed -n '1,200p' client/src/lib/api/mealActions.ts
```

Inside `mealActions.ts`, enforce:

1. **Any function that sends a meal to the backend** (e.g. `saveMeal`, `updateMeal`, `replaceMeal`):

   * If it receives a **normalized meal** from UI (which it should), do **not** try to remap fields like `title`, `item`, etc.

   * Only send what the backend expects. Example pattern (Architect must match to actual):

     ```ts
     // BEFORE â€“ legacy style (example)
     body: JSON.stringify({
       id: meal.id,
       name: meal.name,
       ingredients: meal.ingredients.map(i => ({
         item: i.item,
         amount: i.amount,
         unit: i.unit,
       })),
       instructions: meal.instructions,
       macros: meal.macros,
     })
     ```

     This is actually fine with our normalized output now. What you MUST NOT do is:

     * rename `name` â†’ `title`
     * assume backend returns old shape

2. **Anywhere mealActions consumes a response from `/api/meals`**:

   * Import the normalizer if not already:

     ```ts
     import { normalizeUnifiedMealOutput } from "@/lib/mealEngineApi";
     ```

   * After `await res.json()`, normalize:

     ```ts
     const data = await res.json();
     const meal = normalizeUnifiedMealOutput(data.meal ?? data);
     ```

3. If thereâ€™s a **`logMeal` / `logToMacros`** function that accepts ingredients/macros from existing meals:

   * DO NOT assume `ingredient.item` only â€” we now have `name` and `item`.
   * If you need names, use `ingredient.name || ingredient.item`.

Architect rule:
**No local mini-normalizers. All roads go through `normalizeUnifiedMealOutput`.**

---

## ðŸ›  FIX #8 â€” Shopping List Normalization

**Goal:** Shopping list features use the normalized ingredient structure, not half-broken legacy fields.

Likely files (from prior context):

* `client/src/components/ShoppingAggregateBar.tsx`
* `client/src/pages/mocktails-low-cal-mixers.tsx`
* `client/src/pages/AlcoholLeanAndSocial.tsx`
* maybe `ShoppingListView.tsx` or similar

### ðŸ”§ Architect Script for Fix #8

```bash
rg -n "ShoppingAggregateBar" client/src
rg -n "shopping" client/src | head -n 40
rg -n "shopping-list" client/src || true
```

Then open the main shopping list aggregator:

```bash
sed -n '1,220p' client/src/components/ShoppingAggregateBar.tsx
```

Inside the file(s):

1. Find where ingredients are pulled from meals:

   ```ts
   meal.ingredients.map(...)
   ```

2. Make sure theyâ€™re using the normalized fields:

   * **Preferred display text:** `ingredient.name || ingredient.item`
   * **Quantity:** `ingredient.amount` or `ingredient.quantity ?? ingredient.amount`
   * **Unit:** `ingredient.unit`

3. Kill any weird assumptions like:

   ```ts
   const label = ing.item;
   ```

   Replace with:

   ```ts
   const label = ing.name || ing.item;
   ```

4. Do **not** alter how items are grouped by store/category unless Architect finds a broken assumption tied to old shapes.

Result:
Every feature that builds a shopping list off generated meals now automatically works with the new unified format.

---

## ðŸ›  FIX #9 â€” Premade Categories / Structured Premades

**Goal:** Every premade meal (all categories) uses the same normalized shape as generated meals.

You already normalized `MealPremadePicker.tsx` responses using `normalizeUnifiedMealOutput`. Now we make sure **category-specific premade code** isnâ€™t doing extra transformation.

### ðŸ”§ Architect Script for Fix #9

```bash
rg -n "Premade" client/src
rg -n "premade" client/src
```

Look especially at:

* `client/src/components/pickers/MealPremadePicker.tsx` (already touched)
* Any `Premade`-style pages like:

  * `client/src/pages/AthleteMealsPremade.tsx`
  * `client/src/pages/KidsMealsPremade.tsx`
  * etc. (actual names from rg)

For each premade page:

1. Find response/meal mapping:

   ```ts
   const meals = /* fetched data */;
   const uiMeals = meals.map(/* custom conversion */);
   ```

2. Collapse that into a no-op:

   * If youâ€™re already using `normalizeUnifiedMealOutput` in the picker:

     * Remove any further per-page conversion.
     * Treat meals as already UI-ready.

3. If any premade endpoint still returns raw backend shape:

   * Architect imports `normalizeUnifiedMealOutput` there and normalizes at the edge.

---

## ðŸ›  FIX #10 â€” Global Meal Card Renderer Normalization

**Goal:** Your main meal card component should assume **normalized meals** and stop doing weird field  juggling.

Earlier rg showed:

* `client/src/components/ui/meal-card.tsx:228`
* `client/src/components/MealCard.tsx:82`

These are likely your main card renderers.

### ðŸ”§ Architect Script for Fix #10

```bash
sed -n '40,200p' client/src/components/MealCard.tsx
sed -n '200,320p' client/src/components/ui/meal-card.tsx
```

Inside these components:

1. Make sure they **expect the normalized shape**:

   ```ts
   interface UIMeal {
     name: string;
     ingredients: {
       name?: string;
       item?: string;
       amount?: number;
       unit?: string | null;
       quantity?: number;
       category?: string;
     }[];
     instructions: string[];
     calories?: number;
     protein?: number;
     carbs?: number;
     fat?: number;
     ounces?: number;
   }
   ```

2. Everywhere you show ingredient names:

   ```ts
   const label = ing.name || ing.item;
   ```

3. Everywhere you show quantity:

   ```ts
   const qty = ing.quantity ?? ing.amount ?? 1;
   ```

4. Everywhere you show macros:

   * Use `meal.calories`, `meal.protein`, `meal.carbs`, `meal.fat`
   * Do **not** reach back into `meal.macros.*` inside the card â€” that shouldâ€™ve been flattened by normalizer.

Result:
All cards (Craving, Fridge, Premades, AI, Restaurant, Finder) render meals consistently, without per-feature hacks.

---

## âœ… WHERE YOU ARE NOW

* Generators: unified âœ…
* Normalizer: architect-verified âœ…
* Craving Creator / Fridge Rescue / AI Meal Creator / Finder / Restaurant / Premades / Weekly Board: normalized âœ…
* Next: tighten factory, actions, shopping, premade categories, and cards with the scripts above.

You donâ€™t need to decide anything.
Just hand these blocks to the Architect/Agent **in order** and let them execute & adjust per file.

If any step throws errors or the Agent spits out diffs/logs you donâ€™t like, paste the raw output and weâ€™ll smack it down.
